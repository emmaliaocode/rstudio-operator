import json
from typing import Dict, List

import kopf
from kopf import Logger, PermanentError
from kubernetes.client.exceptions import ApiException
from kubernetes.client.models.v1_persistent_volume_claim_list import V1PersistentVolumeClaimList
from kubernetes.client.models.v1_service import V1Service
from kubernetes.client.models.v1_stateful_set import V1StatefulSet

from builder import BuildApiData
from client import KubernetesClient


def generate_storage_status(name: str, spec: Dict, namespace: str) -> Dict:
    """
    Get the name of the PersistentVolumeClaim generated by the StatefulSet with volumeClaimTemplates

    Args:
        name (str): the name of the custom resource
        spec (dict): the specification part of the custom resource
        namespace (str): the namespace in which the custom resource is created

    Returns:
        dict: a dictionary contains a key-value pair of "storage-pvc" and the PersistentVolumeClaim name
    """

    k8s_client: KubernetesClient = KubernetesClient()

    has_storage: bool = False if spec.get("storages") is None else True
    status: Dict = {}

    try:
        if has_storage:
            pvc_list: V1PersistentVolumeClaimList = k8s_client.core_v1_api.list_namespaced_persistent_volume_claim(
                namespace=namespace, label_selector=f"rstudio={name}"
            )
            status = {"storage-pvc": pvc_list.items[0].metadata.name}
        else:
            status = {"storage-pvc": "storage unspecified"}

    except ApiException as e:
        raise PermanentError(e)

    return status


@kopf.on.create("rstudios")
def create_fn(name: str, spec: Dict, namespace: str, logger: Logger, **_) -> Dict:
    """Handler function that is called when a new rstudio custom resource is created

    Args:
        name (str): the name of the custom resource
        spec (dict): the specification part of the custom resource
        namespace (str): the namespace in which the custom resource is created
        logger (kopf.Logger): the logger instance for logging within the handler
        **kwargs: arbitrary keyword arguments

    Returns:
        dict: a dictionary representing the result of the creation process
    """

    build_api_data: BuildApiData = BuildApiData(name=name, spec=spec)
    k8s_client: KubernetesClient = KubernetesClient()

    tmpls: List = ["statefulset.yaml.j2", "service.yaml.j2"]
    api_data: Dict = {}

    for tmpl in tmpls:
        key: str = str(tmpl).rsplit(".")[0]
        val: Dict = build_api_data.generate_api_data(tmpl)
        kopf.adopt(val)
        api_data.update({key: val})

    try:
        _: V1StatefulSet = k8s_client.app_v1_api.create_namespaced_stateful_set(
            namespace=namespace,
            body=api_data["statefulset"],
        )
        _: V1Service = k8s_client.core_v1_api.create_namespaced_service(
            namespace=namespace,
            body=api_data["service"],
        )

        logger.info(f"`{name}` StatefulSet and Service childs are created.")

    except ApiException as e:
        if e.reason == "Conflict":
            res: Dict = json.loads(e.body)
            raise PermanentError(res["message"])
        else:
            raise PermanentError(e)

    status: Dict = generate_storage_status(name=name, spec=spec, namespace=namespace)

    return status


@kopf.on.update("rstudios")
def update_fn(name: str, spec: Dict, namespace: str, logger: Logger, **_):
    """Handler function that is called when an rstudio custom resource is updated

    Args:
        name (str): the name of the custom resource
        spec (dict): the specification part of the custom resource
        namespace (str): the namespace in which the custom resource is created
        logger (kopf.Logger): the logger instance for logging within the handler
        **kwargs: arbitrary keyword arguments

    Returns:
        dict: a dictionary representing the result of the creation process
    """

    build_api_data: BuildApiData = BuildApiData(name=name, spec=spec)
    k8s_client: KubernetesClient = KubernetesClient()

    api_data: Dict = build_api_data.generate_api_data("statefulset.yaml.j2")
    kopf.adopt(api_data)

    try:
        _: V1StatefulSet = k8s_client.app_v1_api.replace_namespaced_stateful_set(
            name=f"{name}-rstudio", namespace=namespace, body=api_data
        )

        logger.info(f"`{name}` StatefulSet childs are updated.")

    except ApiException as e:
        if e.reason == "Unprocessable Entity":
            res: Dict = json.loads(e.body)
            raise PermanentError(res["message"])
        else:
            raise PermanentError(e)
